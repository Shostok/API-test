1. Компонентный подход

В реакте самое главное это компонентный подход. То есть мы все дробим на составные части. Тут важно учесть, что некоторые компоненты, такие как `App` не переиспользуются несколько раз, а какие-то, пример `Button`, используются по приложению практически везде.

Наша задача разбивать код на мелкие части которые отвечают за какую-то 1 задачу, это называется `Принцип единственной ответственности`. Нужно учитывать, что что-то мы будем использовать повторно. Каждый компонент или модуль, это независимый модуль, то есть он может работать сам по себе, если ты передал в него необходимые параметры, которые называются пропсы (Properties). И также этот компонент сам себя стилизует. В данном случае лучше использовать css-модули и создавать всегда рядом с этим компонентов в отдельной папке. Модуль создается как файл `Name.module.css` и импортируется как `import styles from './Name.module.css`. Называть styles не обязательно, тут как удобно тебе. Потом чтобы использовать стили ты в className пишешь так `className={styles.названиеКласса}`. Важно называть классы в camelCase. То есть первая буква маленькая, остальные первые буквы слова большие. Это нужно, чтобы прочитать это свойство так как у объекта не может быть вот такой хуйни `styles.user-card`, это будет ошибка.


Тут сразу про пропсы. Пропсы это просто параметры функции, потому что компонент это функция, они там лежат в объекте, обычно это выглядит так:

```jsx
export const Button = (props) => {
  return (
    <button className={styles.button} onClick={props.onClick}>
      {props.children}
    </button>
  )
}
```

И используется потом так:

```jsx
<Button onClick={() => doSomething()}>Кнопка<Button />
```

children проп это то что ты кладешь внутрь, то что оборачиваешь, тут это текст `Кнопка`. А остальные параметры, которых может быть неограниченное количество, мы кладем как свойство в html, то есть `() => doSomething()` это значение пропа `onClick`.

Но лучше использовать деструктуризацию, то есть не использовать слово props, а вытаскивать из объекта props сразу параметры. Об этом позже. Но вот пример использования деструктурированных пропсов:

```jsx
export const Button = ({ children, onClick }) => {
  return (
    <button className={styles.button} onClick={onClick}>
      {children}
    </button>
  )
}
```

Тут вы явно берем `children` и `onClick` и потом их используем, это и удобно и ошибок меньше.

2. Структура проекта

Мы делаем взрослое приложение и важно чтобы все лежало по полочкам, полочки это папки. Папки должны называться как что-то глобальное, например `constants`, для константных значений. А внутри папки должны быть файлы или другие папки, которые разбиваются на модули. Например `api` имеет файл `userApi`, там должны быть все запросы, которые связанны с юзерами. И так для каждого отдельного модуля. Все должно быть просто и понятно, чтобы ты сразу понимал что да где и особенно другие разработчики.

Короче константы в `constants`, ютилити функции в `utils`, компоненты в `components`, запросы в `api` и так далее.

3. Экспорты и импорты

Ты мало работал с этим поэтому сразу скажу default экспорты лучше не юзать, кроме случаев когда архитектура проекта или библиотеки нам не говорит обратное.

То есть в конце файла `export default НазваниеКомпонента` так не делаем. Лучше экспортить сверху когда определяешь переменную `export const Button`

Нафига это надо? Потому что когда ты будешь что-то импортировать, например `Button`, то когда ты будешь писать это в коде, код тебе сам подскажешь что это надо экспортнуть и откуда и тебе ничего не нужно делать. И плюс, `default` экспортирует что-то там куда-то там и называть это ты можешь как угодно. У тебя компонент `Button` а ты его импортируешь как `Hueta`, это смешно, но бесполезно в нашем случае. Тут ты никогда не промахнешься и всегда будешь импортировать то, что тебе нужно не запоминая как оно там пишется.

4. Запросы к серверу

Все запросы лучше выносить в отдельный файл, собственно как и все остальное конечно. Но тут особенно. Это удобнее и убирает кучу лишнего кода.

5. Использование `Link`

Лучше использовать для ссылок и не превращать в кнопку. Понимаю что другого ты не знал возможно. Но если тебе нужно перейти на другую страничку или еще как-то использовать роутер, то на этот случай есть хук `useNavigate`. И уже его функцию ты используешь в функциях-обработчиках, такие как `onClick`

6. Переиспользуемость

Еще раз вернемся. Это важный момент. Если ты что-то написал, а потом надо еще куда-то вставить тоже самое или очень похожее, это надо выносить в отельный модуль и экспортировать. И тут речь не только о компонентах, а вообще о всём. Не стоит иногда перебарщивать, но чаще всего переиспользования быть не должно, особенно громоздких конструкций. Посмотри как я сделал со всеми модулями, их теперь можно юзать где угодно и когда угодно. А если надо будет изменить, то я поменяю и оно применится везде. Так проще разрабатывать, тестить, дебажить да и в целом жить только проще от этого.

7. Деструктуризация объекта

Это такой механизм, который позволяет достать нужные параметры из объекта и не использовать его через точку, вот пример:

```js
let user = {
  name: 'Ваня',
  nickname: 'Shostok'
}

// Это обычное использование свойств
user.name // Ваня
user.nickname // Shostok

// Это деструктуризация
const { name, nickname } = user

name // Ваня
nickname // Shostok
```

Когда ты передаешь в функцию или компонент параметры объектом (В компоненте они всегда объектом), то можно деструктурировать прямо внутри объясления аргументов, вот пример:

```js
// В эту фукнцию передают объект user
// Это обычное использование свойств
const sayHi = (user) => {
  console.log(`Hi ${user.name}. I'll call you ${user.nickname}`)
}

// Это деструктуризация
const sayHi = ({ name, nickname }) => {
  console.log(`Hi ${name}. I'll call you ${nickname}`)
}
```

Результат одинаковый, но так делать удобнее и ты еще убедишься в этом.
